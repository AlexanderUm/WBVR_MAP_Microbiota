#############################################################
# Accuraracy of individual samples classificaiton 
# How composition of traing dataset will influcence the classificaiton of individual samples. 
#############################################################

# 0 Prepare enviorment 
########################

# 0.1 Set working directory 

setwd("C://Rprojects/Microbiota_MAP/")

# 0.2 Load libraries 
library(randomForest)
library(ggplot2)


# 0.3 Optimization for parralel processing 
# 0.3.1 Load required libraries 
library(foreach)
library(doParallel)


# 0.3.2 Register claster 
cores=detectCores()
cl <- makeCluster(cores[1]-1) 
registerDoParallel(cl)

# 0.3.3 Remove temp objects 
rm(list = c("cl", "cores"))

metadata <- read.csv("data/metadata/full_metadata.csv")

# 1. Function 1. This function will make a matrix that will be used for following function with 
#                unique subsets of samples in the way that each sample subseted at least onece. 

create_kick_matrix <- function(data, subset_group, group_column, sample_to_test, sub_prop, n.runs) {
        # Subset the sample from data 
        data0 <- data[!rownames(data) %in% as.character(sample_to_test), ]
      # Split data into high and low 
      f.g <- data0[data0[,as.character(group_column)] %in% as.character(subset_group), ]
      nf.g <- data0[!data0[,as.character(group_column)] %in% as.character(subset_group), ]
      
      # Determine number of samples from passed proportion 
      s.n <- round(nrow(f.g)*(1-sub_prop), 0) 
      
      kick.samp.f <- c()
      for (r in 1:n.runs) {
        
          kick.samp <- c()
          rn.f.g <- rownames(f.g)
      
      for (i in 1:floor(nrow(f.g)/s.n)) {
        
         s.kick <- rn.f.g[sample(length(rn.f.g), s.n, replace = FALSE)]
         
         s.kick2 <- c(s.kick, sample_to_test)
         
         rn.f.g <-  rn.f.g[!rn.f.g %in% s.kick]
         
         kick.samp <- cbind(kick.samp, s.kick2)
      }
          nam <- paste("Sampling", 1:floor(nrow(f.g)/s.n), sep = "_")
          nam1 <- paste("Run", r, sep = "_")
          colnames(kick.samp) <- paste(nam, nam1, sep = ";") 
          
          kick.samp.f <- cbind(kick.samp.f, kick.samp)
      }
     
      return(kick.samp.f)
} 


#2. Function 2. Will build a RF model based on "kick matrix" generated by Function 1. 
#               Also will test samples in build rf modles 

rf_en_valid <- function(data, kick_matrix, ntrees, mtry, group_column) {
  
        rf.form <- paste(group_column, "~.", sep = " ") 
  
        votes.out.c <- c()
        confusion.out.c <- c()
        importance.out.c <- c()
        pred.obj.c <- c()
        
        for (i in 1:ncol(kick_matrix)) {
              val.samp <- data[rownames(data) %in% kick_matrix[, i], ]
              train.samp <- data[!rownames(data) %in% kick_matrix[, i], ]
        
             rf.obj <- randomForest::randomForest(as.formula(rf.form), 
                                                    data = train.samp, 
                                                    mtry=mtry,
                                                    ntree=ntrees) 
        
   
             votes.out <- data.frame(rf.obj$votes)
             votes.out$SampleID <- rownames(votes.out)
             votes.out$Run.n <- colnames(kick_matrix)[i]
             votes.out.c <- rbind(votes.out.c, votes.out)
        
             confusion.out <- data.frame(rf.obj$confusion)
             confusion.out$Group <- rownames(confusion.out)
             confusion.out$Run.n <- colnames(kick_matrix)[i] 
             confusion.out.c <- rbind(confusion.out.c,  confusion.out)
        
             importance.out <- data.frame(rf.obj$importance)
             importance.out$tax.id <- rownames(importance.out)
             importance.out$Run.n <- colnames(kick_matrix)[i] 
             importance.out.c <- rbind(importance.out.c, importance.out)
        
       
             pred.obj <-  data.frame(predict(rf.obj, val.samp[, -which(colnames(val.samp) %in% group_column)]))
        
             colnames(pred.obj) <- c("Prediction")
        
             pred.obj$SampleID <- rownames(pred.obj)
             pred.obj$Run.n <- colnames(kick_matrix)[i] 
             pred.obj.c <- rbind(pred.obj.c, pred.obj)
             
             gc()
  }
        
        
        output.obj <- list(Prediction=pred.obj.c,
                            votes=votes.out.c, 
                            confusion=confusion.out.c, 
                            importance=importance.out.c, 
                            Kick.matrix=kick_matrix
                            )
  
   return(output.obj)
 }




#3. Run the loop that will biluld rundom forest models 
samp.classific.out <- list()

for (gr in levels(rfdata$Status))  {
  
    gr.out <- foreach(i=rownames(rfdata)) %dopar% {

    kick.mat <- create_kick_matrix(rfdata, as.character(gr), "Status", as.character(i), 0.9, n.runs = 3)

    rf_en_valid(rfdata, kick_matrix = kick.mat, 
                         mtry = 321, ntrees = 15001, 
                         group_column = "Status") }
  
    samp.classific.out[[gr]] <- gr.out
}

#save(samp.classific.out, file = "output/processing/samp_classific_out.Rdata") 



#4. Visuallize classificaiton accuracy 
######################################

#4.1. Extract data for visualisation 

pred.f <- c()

pred.ind.f <- c()

# 4.1.1.a first level of the loop - process separately "High" and "Low" shedding part from 
#         object produced by step 3. 
for (cl in names(samp.classific.out)) {
  #a. Subset target object 
  cl.obj <- samp.classific.out[[cl]]
  
  #a. Make empty vectors to store :
  #a.1 - all information about classification per object 
  pred.c <- c()
  
  #a.2 - classification information only about targeted sample 
  pred.ind.c <- c()
  
  
  # 4.1.1.b Second level (nested) loop. combine in one matrix classification information from each samples 
  for (sp in 1:length(cl.obj)) {
    
    #b.1) Extract prediction dataframe for a sample 
    pred.ind <- cl.obj[[sp]]$Prediction
    
    #b.1) Add collumn with sample number 
    pred.ind$Tested.samp.ID <- sp
    
    #b.1) Bind information from all samples into one dataframe 
    pred.c <- rbind(pred.c,  pred.ind)
    
    
    #b.2) Extract only lines corresponding to target sample of the run 
    pred.ind.sp <- pred.ind[pred.ind$SampleID %in% rownames(rfdata)[sp], ]
    
    #b.2) Extract metadata corresponding only to selected sample  
    sp.metad <- metadata[metadata$Plate.position %in% rownames(rfdata)[sp], ]
    
    #b.2) Bind information from all samples into one dataframe 
    pred.ind.sp <- cbind( pred.ind.sp, sp.metad[rep(1, nrow(pred.ind.sp)), ])
    
    #b.2) Bind information from all samples into one dataframe
    pred.ind.c <- rbind(pred.ind.c, pred.ind.sp)
    
  }
  
  #a.1 Add a column with the name of cattegory that was subsetted 
  pred.c$Sub.group <- cl
  
  #a.1 Bind togather from both categories into a dataframe 
  pred.f <- rbind(pred.f, pred.c)
  
  #a.2 Add a column with the name of cattegory that was subsetted 
  #    to object with infrmation only from corresponding samples 
  pred.ind.c$Sub.group <- cl
  
  #a.2 Bind togather from both categories into a dataframe 
  pred.ind.f <- rbind(pred.ind.f, pred.ind.c)
}
rm(list = c("cl", "sp", "pred.c", "pred.ind.c", "pred.ind.sp", "sp.metad", "pred.ind", "cl.obj"))
gc()


# 4.2 Add collumns requered for visualasation 
# 4.2.1 Add count columns for nubmer of attempts 
pred.ind.f$y <- 1

# 4.2.2 Convert sheading into factors - will remove empty levels 
pred.ind.f$Shading <- as.factor(as.character(pred.ind.f$Shading))

# 4.2.3 Add column with infomation about correctness of classification 
pred.ind.f$Classified <- as.factor(ifelse(as.character(pred.ind.f$Prediction) == as.character(pred.ind.f$Status), 
                                          "Correctly", "Incorrectly"))

# 4.2.4 Add collumn with year and month 
pred.ind.f$Year_Month <- paste(as.character(pred.ind.f$Year), 
                                ifelse(nchar(as.character(pred.ind.f$Month)) == 1, 
                                       paste0("0", as.character(pred.ind.f$Month)), 
                                       as.character(pred.ind.f$Month)), 
                                sep = "_") 

# 4.2.5 Add column that combined samples ID and Year_Month - used as x axis 
pred.ind.f$x <- paste(pred.ind.f$Year_Month, pred.ind.f$SampleID, sep = "/")


# 4.3 Select samples only from low shaders 
pred.ind.f.low <- pred.ind.f[pred.ind.f$Status %in% "Low", ]

# 4.3.1 Plot samples classification for low shedders 
p.class.low <- ggplot(pred.ind.f.low, aes(x=x, y=y, fill=Classified, color = Shading)) + 
  geom_bar(stat = "identity", size=0.6) +
  facet_grid(Sub.group ~ CowID, scales = "free_x", space = "free" ) + 
  theme_bw() + 
  scale_fill_manual(values = c( "gray95", "black")) + 
  scale_color_brewer(palette="Set1") + 
  theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1)) + 
  xlab("Year_Month/ID") + 
  ylab("Classification attempts")

# 4.3.2 Save the plot 
ggsave( "output/plots/classification_accur_low.pdf", p.class.low)
ggsave( "output/plots/classification_accur_low.png", p.class.low, dpi = 300)

table(pred.ind.f.low$Classified)/sum(table(pred.ind.f.low$Classified))*100

table(pred.ind.f.low$Classified[pred.ind.f.low$Sub.group %in% "High"])/length(pred.ind.f.low$Classified[pred.ind.f.low$Sub.group %in% "High"])*100

table(pred.ind.f.low$Classified[pred.ind.f.low$Sub.group %in% "Low"])/length(pred.ind.f.low$Classified[pred.ind.f.low$Sub.group %in% "Low"])*100

rm(list = c("pred.ind.f.low", "p.class.low"))


# 4.4 Select samples only from high shaders 
pred.ind.f.high <- pred.ind.f[pred.ind.f$Status %in% "High", ]

# 4.4.1 Plot samples classification for high shedders 
p.class.high <- ggplot(pred.ind.f.high, aes(x=x, y=y, fill=Classified, color = Shading)) + 
  geom_bar(stat = "identity", size=0.6) +
  facet_grid(Sub.group ~ CowID, scales = "free_x", space = "free" ) + 
  theme_bw() + 
  scale_fill_manual(values = c( "gray95", "black")) + 
  scale_color_brewer(palette="Set1")+ 
  theme(axis.text.x = element_text(angle = 90, vjust=0.5, hjust=1)) + 
  xlab("Year_Month/ID") + 
  ylab("Classification attempts")

# 4.4.2 Save the plot 
ggsave( "output/plots/classification_accur_high.pdf", p.class.high)
ggsave( "output/plots/classification_accur_high.png", p.class.high, dpi = 300)

table(pred.ind.f.high$Classified)/sum(table(pred.ind.f.high$Classified))*100

table(pred.ind.f.high$Classified[pred.ind.f.high$Sub.group %in% "High"])/length(pred.ind.f.high$Classified[pred.ind.f.high$Sub.group %in% "High"])*100

table(pred.ind.f.high$Classified[pred.ind.f.high$Sub.group %in% "Low"])/length(pred.ind.f.high$Classified[pred.ind.f.high$Sub.group %in% "Low"])*100

rm(list = c("pred.ind.f.high", "p.class.high"))

